# 분할 정복

### 학습 목표

- 문제를 분할해서 해결하는 분할 정복(Devide and Conquer) 기법을 이해한다.

- 대표적인 알고리즘인 퀵 정렬과 병합 정렬, 이진 검색에 대해 학습한다.

### Top-down approach

### 병합 정렬

- 여러 개의 정렬된 자료의 집합을 병하바여 한 개의 정렬된 집합으로 만드는 방식

- 분할 정복 알고리즘 활용

  - 자료를 최소 단위의 문제까지 나눈 후에 차례대로 정렬하여 최종 결과를 얻어냄.
  - top-down 방식

- 시간 복잡도
  - O(n log n)

1. 분할 : 리스트의 길이가 1일 때까지 분할
2. 정복 : 리스트의 길이가 1이 되면 자동으로 정렬됨
3. 병합 : - 왼쪽, 오른쪽 리스트 중 작은 원소부터 정답 리스트에 추가하면서 진행

### 퀵 정렬 - 피봇 선택에 따른 성능차이

- 평균적인 속도가 O(NlogN)으로 빠르다.
- 특히 대규모의 데이터일 때 효과적으로 동작

- 주어진 배열을 두 개로 분할하고, 각각을 정렬한다.

  - 병합 정렬과 동일?

- 다른 점 1 : 병합 정렬은 그냥 두 부분으로 나누는 반면에, 퀵 정렬은 분할할 때, 기준 아이템(pivot item) 중심으로 분할한다.

  - 기준보다 작은 것은 왼편, 큰 것은 오른편에 위치시킨다.

- 다른 점 2 : 각 부분 정렬이 끝난 후, 병합정렬은 "병합"이란 후처리 작업이 필요하나, 퀵 정렬은 필요로 하지 않는다.

- Quick Sort 는 Partitioning 이라는 과정을 반복하면서, **평균 시간복잡도 O(nlogn)**속도라는 빠른 속도로 정렬이 되는 Sort이다. - 최악 : O(n^2)

1. 작업영역을 정한다.

2. 작업영역 중 가장 왼쪽에 있는 수를 Pivot 이라고 하자. (Pivot을 "기준"으로 해석한다.)

3. Pivot을 기준으로 왼쪽에는 Pivot 보다 작은 수를 배치한다. (정렬 안됨)
   오른쪽에는 Pivot 보다 큰 수를 배치시킨다. (정렬 안됨)

### Lomuto partition 알고리즘

- 구현이 더 쉽다
- 쉬운만큼 느리다. (대부분 느리며, 최악은 동일하다)
  - 호어 파티션 모두 역순 정렬이 되어있을 때 최악의 성능. 또는 pivot 설정 잘못했을 때 O(N^2)

### 이진 검색

- 